<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>KoreanDub - Video Translation</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">

    <style>
        :root {
            --primary: #6366F1;
            --primary-hover: #4F46E5;
            --accent: #22D3EE;
            --success: #22C55E;
            --warning: #F59E0B;
            --error: #EF4444;
            --bg: #0F172A;
            --bg-card: #1E293B;
            --bg-input: #334155;
            --border: #475569;
            --text: #F8FAFC;
            --text-secondary: #94A3B8;
            --text-muted: #64748B;
        }

        * { margin: 0; padding: 0; box-sizing: border-box; }

        body {
            font-family: 'Inter', sans-serif;
            background: var(--bg);
            color: var(--text);
            min-height: 100vh;
            line-height: 1.5;
        }

        .container {
            max-width: 1000px;
            margin: 0 auto;
            padding: 40px 24px;
        }

        /* Header */
        header {
            text-align: center;
            margin-bottom: 48px;
        }

        .logo {
            font-size: 28px;
            font-weight: 700;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }

        .tagline {
            color: var(--text-secondary);
            font-size: 16px;
        }

        /* Main Card */
        .main-card {
            background: var(--bg-card);
            border-radius: 16px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        /* API Config */
        .api-config {
            padding: 20px 24px;
            background: rgba(99, 102, 241, 0.05);
            border-bottom: 1px solid var(--border);
        }

        .api-config-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }

        .api-config-header h3 {
            font-size: 14px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .api-config-header h3 svg {
            width: 18px;
            height: 18px;
            stroke: var(--primary);
        }

        .api-toggle {
            font-size: 13px;
            color: var(--primary);
            background: none;
            border: none;
            cursor: pointer;
        }

        .api-keys {
            display: none;
            grid-template-columns: repeat(3, 1fr);
            gap: 16px;
            margin-top: 16px;
        }

        .api-keys.show { display: grid; }

        .api-field label {
            display: block;
            font-size: 12px;
            color: var(--text-secondary);
            margin-bottom: 6px;
        }

        .api-field input {
            width: 100%;
            padding: 10px 12px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg-input);
            color: var(--text);
            font-size: 13px;
            font-family: monospace;
        }

        .api-field input:focus {
            outline: none;
            border-color: var(--primary);
        }

        .api-status {
            font-size: 11px;
            margin-top: 4px;
        }

        .api-status.ok { color: var(--success); }
        .api-status.missing { color: var(--text-muted); }

        /* Upload Section */
        .upload-section {
            padding: 32px 24px;
        }

        .upload-zone {
            border: 2px dashed var(--border);
            border-radius: 12px;
            padding: 48px 24px;
            text-align: center;
            cursor: pointer;
            transition: all 0.2s;
            background: var(--bg);
        }

        .upload-zone:hover {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.05);
        }

        .upload-zone.dragover {
            border-color: var(--accent);
            background: rgba(34, 211, 238, 0.1);
        }

        .upload-zone.has-file {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.05);
        }

        .upload-icon {
            width: 48px;
            height: 48px;
            margin: 0 auto 16px;
            stroke: var(--text-muted);
        }

        .upload-zone.has-file .upload-icon {
            stroke: var(--success);
        }

        .upload-text {
            font-size: 16px;
            font-weight: 500;
            margin-bottom: 8px;
        }

        .upload-hint {
            font-size: 13px;
            color: var(--text-muted);
        }

        .file-info {
            display: none;
            margin-top: 16px;
            padding: 12px 16px;
            background: var(--bg-input);
            border-radius: 8px;
            text-align: left;
        }

        .upload-zone.has-file .file-info {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .file-icon {
            width: 40px;
            height: 40px;
            background: var(--primary);
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .file-icon svg {
            width: 20px;
            height: 20px;
            stroke: white;
        }

        .file-details {
            flex: 1;
        }

        .file-name {
            font-weight: 500;
            font-size: 14px;
        }

        .file-size {
            font-size: 12px;
            color: var(--text-muted);
        }

        .file-remove {
            padding: 8px;
            background: none;
            border: none;
            cursor: pointer;
            color: var(--text-muted);
        }

        .file-remove:hover { color: var(--error); }

        /* Video Preview */
        .video-preview {
            display: none;
            margin-top: 20px;
        }

        .video-preview.show { display: block; }

        .video-preview video {
            width: 100%;
            border-radius: 8px;
            background: #000;
        }

        /* Options Section */
        .options-section {
            padding: 24px;
            border-top: 1px solid var(--border);
        }

        .options-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            color: var(--text-secondary);
        }

        .options-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 16px;
        }

        .option-card {
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border);
            background: var(--bg);
            cursor: pointer;
            transition: all 0.2s;
        }

        .option-card:hover {
            border-color: var(--primary);
        }

        .option-card.selected {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.1);
        }

        .option-header {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .option-checkbox {
            width: 22px;
            height: 22px;
            border-radius: 6px;
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .option-card.selected .option-checkbox {
            background: var(--primary);
            border-color: var(--primary);
        }

        .option-checkbox svg {
            width: 14px;
            height: 14px;
            stroke: white;
            opacity: 0;
        }

        .option-card.selected .option-checkbox svg {
            opacity: 1;
        }

        .option-icon {
            width: 24px;
            height: 24px;
            stroke: var(--text-muted);
        }

        .option-card.selected .option-icon {
            stroke: var(--primary);
        }

        .option-label {
            font-weight: 600;
            font-size: 15px;
        }

        .option-desc {
            font-size: 13px;
            color: var(--text-muted);
            margin-left: 34px;
        }

        /* Voice Selection */
        .voice-section {
            display: none;
            padding: 20px 24px;
            border-top: 1px solid var(--border);
            background: rgba(34, 211, 238, 0.02);
        }

        .voice-section.show { display: block; }

        .voice-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 12px;
            color: var(--text-secondary);
        }

        .voice-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 12px;
        }

        .voice-card {
            padding: 14px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--bg);
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
        }

        .voice-card:hover {
            border-color: var(--accent);
        }

        .voice-card.selected {
            border-color: var(--accent);
            background: rgba(34, 211, 238, 0.1);
        }

        .voice-avatar {
            width: 40px;
            height: 40px;
            margin: 0 auto 8px;
            border-radius: 50%;
            background: linear-gradient(135deg, var(--primary), var(--accent));
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 700;
            font-size: 14px;
        }

        .voice-name {
            font-weight: 600;
            font-size: 13px;
            margin-bottom: 2px;
        }

        .voice-type {
            font-size: 11px;
            color: var(--text-muted);
        }

        /* Process Button */
        .process-section {
            padding: 24px;
            border-top: 1px solid var(--border);
        }

        .process-btn {
            width: 100%;
            padding: 16px;
            border-radius: 10px;
            border: none;
            background: linear-gradient(135deg, var(--primary), #8B5CF6);
            color: white;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.2s;
        }

        .process-btn:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 30px rgba(99, 102, 241, 0.3);
        }

        .process-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .process-btn svg {
            width: 20px;
            height: 20px;
        }

        .spinner {
            width: 20px;
            height: 20px;
            border: 2px solid rgba(255,255,255,0.3);
            border-top-color: white;
            border-radius: 50%;
            animation: spin 0.8s linear infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        /* Pipeline Progress */
        .pipeline {
            display: none;
            padding: 24px;
            border-top: 1px solid var(--border);
        }

        .pipeline.show { display: block; }

        .pipeline-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .pipeline-steps {
            display: flex;
            justify-content: space-between;
            position: relative;
        }

        .pipeline-steps::before {
            content: '';
            position: absolute;
            top: 20px;
            left: 40px;
            right: 40px;
            height: 2px;
            background: var(--border);
        }

        .pipeline-step {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 8px;
            position: relative;
            z-index: 1;
        }

        .step-icon {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: var(--bg-input);
            border: 2px solid var(--border);
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .step-icon svg {
            width: 18px;
            height: 18px;
            stroke: var(--text-muted);
        }

        .pipeline-step.active .step-icon {
            border-color: var(--primary);
            background: rgba(99, 102, 241, 0.2);
        }

        .pipeline-step.active .step-icon svg {
            stroke: var(--primary);
        }

        .pipeline-step.done .step-icon {
            border-color: var(--success);
            background: rgba(34, 197, 94, 0.2);
        }

        .pipeline-step.done .step-icon svg {
            stroke: var(--success);
        }

        .pipeline-step.error .step-icon {
            border-color: var(--error);
            background: rgba(239, 68, 68, 0.2);
        }

        .pipeline-step.error .step-icon svg {
            stroke: var(--error);
        }

        .step-label {
            font-size: 12px;
            color: var(--text-muted);
            font-weight: 500;
        }

        .pipeline-step.active .step-label,
        .pipeline-step.done .step-label {
            color: var(--text);
        }

        /* Current Step Info */
        .current-step-info {
            margin-top: 20px;
            padding: 16px;
            background: var(--bg);
            border-radius: 10px;
            border: 1px solid var(--border);
        }

        .step-status {
            font-size: 14px;
            font-weight: 500;
            margin-bottom: 4px;
        }

        .step-detail {
            font-size: 13px;
            color: var(--text-muted);
        }

        /* Results Section */
        .results {
            display: none;
            padding: 24px;
            border-top: 1px solid var(--border);
        }

        .results.show { display: block; }

        .results-title {
            font-size: 14px;
            font-weight: 600;
            margin-bottom: 16px;
            display: flex;
            align-items: center;
            gap: 8px;
            color: var(--success);
        }

        .results-title svg {
            width: 20px;
            height: 20px;
            stroke: var(--success);
        }

        .result-tabs {
            display: flex;
            gap: 8px;
            margin-bottom: 16px;
        }

        .result-tab {
            padding: 10px 16px;
            border-radius: 8px;
            border: 1px solid var(--border);
            background: var(--bg);
            color: var(--text-secondary);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        .result-tab.active {
            background: var(--primary);
            border-color: var(--primary);
            color: white;
        }

        .result-content {
            background: var(--bg);
            border-radius: 10px;
            border: 1px solid var(--border);
            overflow: hidden;
        }

        .result-panel {
            display: none;
        }

        .result-panel.active {
            display: block;
        }

        /* Transcript Display */
        .transcript {
            max-height: 300px;
            overflow-y: auto;
            padding: 16px;
        }

        .transcript-line {
            display: flex;
            gap: 12px;
            padding: 10px 0;
            border-bottom: 1px solid var(--border);
        }

        .transcript-line:last-child {
            border-bottom: none;
        }

        .transcript-time {
            font-size: 12px;
            color: var(--accent);
            font-family: monospace;
            min-width: 80px;
        }

        .transcript-text {
            flex: 1;
        }

        .transcript-original {
            font-size: 14px;
            margin-bottom: 4px;
            color: var(--text-secondary);
        }

        .transcript-korean {
            font-size: 15px;
            color: var(--text);
        }

        /* Audio Player */
        .audio-result {
            padding: 16px;
        }

        .audio-player {
            display: flex;
            align-items: center;
            gap: 16px;
            padding: 16px;
            background: var(--bg-card);
            border-radius: 10px;
        }

        .play-btn {
            width: 48px;
            height: 48px;
            border-radius: 50%;
            background: var(--accent);
            border: none;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .play-btn svg {
            width: 24px;
            height: 24px;
            fill: var(--bg);
        }

        .audio-info {
            flex: 1;
        }

        .audio-title {
            font-weight: 600;
            font-size: 14px;
            margin-bottom: 4px;
        }

        .audio-duration {
            font-size: 12px;
            color: var(--text-muted);
        }

        .download-btn {
            padding: 10px 20px;
            border-radius: 8px;
            border: 1px solid var(--accent);
            background: transparent;
            color: var(--accent);
            font-size: 13px;
            font-weight: 500;
            cursor: pointer;
        }

        .download-btn:hover {
            background: rgba(34, 211, 238, 0.1);
        }

        /* Video Result */
        .video-result {
            padding: 16px;
        }

        .video-result video {
            width: 100%;
            border-radius: 8px;
        }

        /* Toast */
        .toast {
            position: fixed;
            bottom: 24px;
            right: 24px;
            padding: 14px 20px;
            border-radius: 10px;
            background: var(--bg-card);
            border: 1px solid var(--border);
            display: flex;
            align-items: center;
            gap: 10px;
            z-index: 9999;
            transform: translateY(100px);
            opacity: 0;
            transition: all 0.3s;
        }

        .toast.show {
            transform: translateY(0);
            opacity: 1;
        }

        .toast.error { border-color: var(--error); }
        .toast.success { border-color: var(--success); }

        .toast svg {
            width: 20px;
            height: 20px;
        }

        .toast.error svg { stroke: var(--error); }
        .toast.success svg { stroke: var(--success); }

        /* Responsive */
        @media (max-width: 768px) {
            .api-keys { grid-template-columns: 1fr; }
            .options-grid { grid-template-columns: 1fr; }
            .voice-grid { grid-template-columns: repeat(2, 1fr); }
            .pipeline-steps { flex-wrap: wrap; gap: 16px; justify-content: center; }
            .pipeline-steps::before { display: none; }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <div class="logo">KoreanDub</div>
            <p class="tagline">Upload English video → Get Korean subtitles & dubbing</p>
        </header>

        <div class="main-card">
            <!-- API Configuration -->
            <div class="api-config">
                <div class="api-config-header" onclick="toggleApiKeys()">
                    <h3>
                        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                            <rect x="3" y="11" width="18" height="11" rx="2"/>
                            <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
                        </svg>
                        API Keys
                    </h3>
                    <button class="api-toggle" id="apiToggle">Show</button>
                </div>
                <div class="api-keys" id="apiKeys">
                    <div class="api-field">
                        <label>OpenAI API Key (Whisper)</label>
                        <input type="password" id="openaiKey" placeholder="sk-..." oninput="saveKey('openai', this.value)">
                        <div class="api-status missing" id="openaiStatus">Required for transcription</div>
                    </div>
                    <div class="api-field">
                        <label>xAI Grok API Key (Translation)</label>
                        <input type="password" id="grokKey" placeholder="xai-..." oninput="saveKey('grok', this.value)">
                        <div class="api-status missing" id="grokStatus">Required for translation</div>
                    </div>
                    <div class="api-field">
                        <label>ElevenLabs API Key (TTS)</label>
                        <input type="password" id="elevenKey" placeholder="sk_..." oninput="saveKey('eleven', this.value)">
                        <div class="api-status missing" id="elevenStatus">Required for dubbing</div>
                    </div>
                </div>
            </div>

            <!-- Upload Section -->
            <div class="upload-section">
                <div class="upload-zone" id="uploadZone" onclick="document.getElementById('fileInput').click()">
                    <svg class="upload-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/>
                        <polyline points="17 8 12 3 7 8"/>
                        <line x1="12" y1="3" x2="12" y2="15"/>
                    </svg>
                    <p class="upload-text">Drop your video here or click to upload</p>
                    <p class="upload-hint">MP4, MOV, AVI, WebM (max 500MB)</p>
                    
                    <div class="file-info">
                        <div class="file-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="23 7 16 12 23 17 23 7"/>
                                <rect x="1" y="5" width="15" height="14" rx="2"/>
                            </svg>
                        </div>
                        <div class="file-details">
                            <div class="file-name" id="fileName"></div>
                            <div class="file-size" id="fileSize"></div>
                        </div>
                        <button class="file-remove" onclick="event.stopPropagation(); removeFile()">
                            <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <line x1="18" y1="6" x2="6" y2="18"/>
                                <line x1="6" y1="6" x2="18" y2="18"/>
                            </svg>
                        </button>
                    </div>
                    
                    <input type="file" id="fileInput" accept="video/*" style="display:none" onchange="handleFile(this.files[0])">
                </div>

                <div class="video-preview" id="videoPreview">
                    <video id="previewVideo" controls></video>
                </div>
            </div>

            <!-- Output Options -->
            <div class="options-section">
                <div class="options-title">Output Options</div>
                <div class="options-grid">
                    <div class="option-card selected" id="optSubtitle" onclick="toggleOption('subtitle')">
                        <div class="option-header">
                            <div class="option-checkbox">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"/>
                                </svg>
                            </div>
                            <svg class="option-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2"/>
                                <line x1="8" y1="21" x2="16" y2="21"/>
                                <line x1="12" y1="17" x2="12" y2="21"/>
                                <line x1="6" y1="10" x2="10" y2="10"/>
                                <line x1="6" y1="13" x2="18" y2="13"/>
                            </svg>
                            <span class="option-label">Korean Subtitles</span>
                        </div>
                        <p class="option-desc">Generate Korean subtitles (SRT file)</p>
                    </div>
                    <div class="option-card selected" id="optDubbing" onclick="toggleOption('dubbing')">
                        <div class="option-header">
                            <div class="option-checkbox">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"/>
                                </svg>
                            </div>
                            <svg class="option-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                                <path d="M19.07 4.93a10 10 0 0 1 0 14.14"/>
                            </svg>
                            <span class="option-label">Korean Dubbing</span>
                        </div>
                        <p class="option-desc">Generate Korean voice-over audio</p>
                    </div>
                </div>
                
                <div class="burn-option" id="burnOption" style="margin-top: 16px; display: none;">
                    <div class="option-card" id="optBurnSub" onclick="toggleOption('burnSub')">
                        <div class="option-header">
                            <div class="option-checkbox">
                                <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3">
                                    <polyline points="20 6 9 17 4 12"/>
                                </svg>
                            </div>
                            <svg class="option-icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="3" width="20" height="14" rx="2"/>
                                <path d="M8 21h8"/>
                                <path d="M12 17v4"/>
                                <path d="M7 9h4"/>
                                <path d="M7 12h10"/>
                            </svg>
                            <span class="option-label">Burn Subtitles into Video</span>
                        </div>
                        <p class="option-desc">Hard-code Korean subtitles (cannot be turned off)</p>
                    </div>
                </div>
            </div>

            <div class="voice-section" id="voiceSection">
                <div class="voice-title">Select Korean Voice</div>
                <div class="voice-grid">
                    <div class="voice-card selected" data-voice="4JJwo477JUAx3HV0T7n7" onclick="selectVoice(this)">
                        <div class="voice-avatar">YK</div>
                        <div class="voice-name">YohanKoo</div>
                        <div class="voice-type">Male, 30s</div>
                    </div>
                    <div class="voice-card" data-voice="AW5wrnG1jVizOYY7R1Oo" onclick="selectVoice(this)">
                        <div class="voice-avatar">JY</div>
                        <div class="voice-name">JiYoung</div>
                        <div class="voice-type">Female</div>
                    </div>
                    <div class="voice-card" data-voice="DMkRitQrfpiddSQT5adl" onclick="selectVoice(this)">
                        <div class="voice-avatar">JJ</div>
                        <div class="voice-name">Jjeong</div>
                        <div class="voice-type">Female, 30s</div>
                    </div>
                    <div class="voice-card" data-voice="Ir7oQcBXWiq4oFGROCfj" onclick="selectVoice(this)">
                        <div class="voice-avatar">TM</div>
                        <div class="voice-name">Taemin</div>
                        <div class="voice-type">Male, 20s</div>
                    </div>
                </div>
            </div>

            <!-- Process Button -->
            <div class="process-section">
                <button class="process-btn" id="processBtn" onclick="startProcessing()" disabled>
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polygon points="5 3 19 12 5 21 5 3"/>
                    </svg>
                    Start Processing
                </button>
            </div>

            <!-- Pipeline Progress -->
            <div class="pipeline" id="pipeline">
                <div class="pipeline-title">
                    <svg width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <circle cx="12" cy="12" r="10"/>
                        <polyline points="12 6 12 12 16 14"/>
                    </svg>
                    Processing Pipeline
                </div>
                <div class="pipeline-steps">
                    <div class="pipeline-step" id="stepExtract">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M9 18V5l12-2v13"/>
                                <circle cx="6" cy="18" r="3"/>
                                <circle cx="18" cy="16" r="3"/>
                            </svg>
                        </div>
                        <span class="step-label">Extract Audio</span>
                    </div>
                    <div class="pipeline-step" id="stepTranscribe">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M12 2a3 3 0 0 0-3 3v7a3 3 0 0 0 6 0V5a3 3 0 0 0-3-3z"/>
                                <path d="M19 10v2a7 7 0 0 1-14 0v-2"/>
                            </svg>
                        </div>
                        <span class="step-label">Transcribe</span>
                    </div>
                    <div class="pipeline-step" id="stepTranslate">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <path d="M5 8l6 6M4 14l6-6 2 2"/>
                                <rect x="14" y="4" width="6" height="6" rx="1"/>
                                <rect x="14" y="14" width="6" height="6" rx="1"/>
                            </svg>
                        </div>
                        <span class="step-label">Translate</span>
                    </div>
                    <div class="pipeline-step" id="stepTTS">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polygon points="11 5 6 9 2 9 2 15 6 15 11 19 11 5"/>
                                <path d="M15.54 8.46a5 5 0 0 1 0 7.07"/>
                            </svg>
                        </div>
                        <span class="step-label">Generate Audio</span>
                    </div>
                    <div class="pipeline-step" id="stepCompose">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <rect x="2" y="2" width="20" height="20" rx="2.18"/>
                                <line x1="7" y1="2" x2="7" y2="22"/>
                                <line x1="17" y1="2" x2="17" y2="22"/>
                                <line x1="2" y1="12" x2="22" y2="12"/>
                            </svg>
                        </div>
                        <span class="step-label">Compose Video</span>
                    </div>
                    <div class="pipeline-step" id="stepDone">
                        <div class="step-icon">
                            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                                <polyline points="20 6 9 17 4 12"/>
                            </svg>
                        </div>
                        <span class="step-label">Complete</span>
                    </div>
                </div>
                <div class="current-step-info" id="stepInfo">
                    <div class="step-status" id="stepStatus">Initializing...</div>
                    <div class="step-detail" id="stepDetail">Preparing to process your video</div>
                </div>
            </div>

            <!-- Results -->
            <div class="results" id="results">
                <div class="results-title">
                    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                        <polyline points="20 6 9 17 4 12"/>
                    </svg>
                    Processing Complete
                </div>
                <div class="result-tabs">
                    <button class="result-tab active" onclick="showResultTab('transcript')">Transcript</button>
                    <button class="result-tab" onclick="showResultTab('video')" id="tabVideo" style="display:none">Video</button>
                    <button class="result-tab" onclick="showResultTab('audio')" id="tabAudio" style="display:none">Audio</button>
                    <button class="result-tab" onclick="showResultTab('download')">Download</button>
                </div>
                <div class="result-content">
                    <div class="result-panel active" id="panelTranscript">
                        <div class="transcript" id="transcriptContent"></div>
                    </div>
                    <div class="result-panel" id="panelVideo">
                        <div class="video-result">
                            <video id="resultVideo" controls style="width: 100%; border-radius: 8px;"></video>
                            <div style="margin-top: 12px; text-align: center;">
                                <button class="download-btn" onclick="downloadVideo()" style="padding: 12px 24px;">
                                    Download Korean Dubbed Video (MP4)
                                </button>
                            </div>
                        </div>
                    </div>
                    <div class="result-panel" id="panelAudio">
                        <div class="audio-result">
                            <div class="audio-player">
                                <button class="play-btn" id="audioPlayBtn" onclick="toggleResultAudio()">
                                    <svg viewBox="0 0 24 24" id="audioPlayIcon">
                                        <polygon points="5 3 19 12 5 21 5 3"/>
                                    </svg>
                                </button>
                                <div class="audio-info">
                                    <div class="audio-title">Korean Dubbed Audio</div>
                                    <div class="audio-duration" id="audioDuration">--:--</div>
                                </div>
                                <button class="download-btn" onclick="downloadAudio()">Download MP3</button>
                            </div>
                            <audio id="resultAudio"></audio>
                        </div>
                    </div>
                    <div class="result-panel" id="panelDownload">
                        <div class="audio-result">
                            <div style="display: flex; flex-direction: column; gap: 12px; padding: 8px 0;">
                                <button class="download-btn" onclick="downloadVideo()" id="btnDownloadVideo" style="width: 100%; padding: 14px; background: var(--primary); border-color: var(--primary); color: white; display: none;">
                                    Download Korean Dubbed Video (MP4)
                                </button>
                                <button class="download-btn" onclick="downloadSRT()" id="btnDownloadSRT" style="width: 100%; padding: 14px;">
                                    Download Korean Subtitles (SRT)
                                </button>
                                <button class="download-btn" onclick="downloadAudio()" id="btnDownloadAudio" style="width: 100%; padding: 14px; display: none;">
                                    Download Korean Audio (MP3)
                                </button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div class="toast" id="toast">
        <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
            <polyline points="20 6 9 17 4 12"/>
        </svg>
        <span id="toastMsg"></span>
    </div>

    <script>
        const state = {
            file: null,
            videoUrl: null,
            videoDuration: 0,
            options: { subtitle: true, dubbing: true, burnSub: false },
            voice: '4JJwo477JUAx3HV0T7n7',
            keys: {
                openai: localStorage.getItem('kd_openai') || '',
                grok: localStorage.getItem('kd_grok') || '',
                eleven: localStorage.getItem('kd_eleven') || ''
            },
            transcript: [],
            audioBlob: null,
            videoBlob: null,
            ffmpeg: null,
            ffmpegLoaded: false
        };

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            document.getElementById('openaiKey').value = state.keys.openai;
            document.getElementById('grokKey').value = state.keys.grok;
            document.getElementById('elevenKey').value = state.keys.eleven;
            updateApiStatus();
            updateVoiceSection();
            updateProcessBtn();

            // Drag & drop
            const zone = document.getElementById('uploadZone');
            zone.addEventListener('dragover', e => { e.preventDefault(); zone.classList.add('dragover'); });
            zone.addEventListener('dragleave', () => zone.classList.remove('dragover'));
            zone.addEventListener('drop', e => {
                e.preventDefault();
                zone.classList.remove('dragover');
                if (e.dataTransfer.files[0]) handleFile(e.dataTransfer.files[0]);
            });
        });

        // API Keys
        function toggleApiKeys() {
            const keys = document.getElementById('apiKeys');
            const toggle = document.getElementById('apiToggle');
            const show = !keys.classList.contains('show');
            keys.classList.toggle('show', show);
            toggle.textContent = show ? 'Hide' : 'Show';
        }

        function saveKey(type, value) {
            state.keys[type] = value;
            localStorage.setItem(`kd_${type}`, value);
            updateApiStatus();
            updateProcessBtn();
        }

        function updateApiStatus() {
            const checks = {
                openai: { el: 'openaiStatus', valid: state.keys.openai.startsWith('sk-') },
                grok: { el: 'grokStatus', valid: state.keys.grok.startsWith('xai-') },
                eleven: { el: 'elevenStatus', valid: state.keys.eleven.length > 10 }
            };

            for (const [key, check] of Object.entries(checks)) {
                const el = document.getElementById(check.el);
                if (check.valid) {
                    el.className = 'api-status ok';
                    el.textContent = '✓ Configured';
                } else {
                    el.className = 'api-status missing';
                    el.textContent = key === 'openai' ? 'Required for transcription' :
                                    key === 'grok' ? 'Required for translation' : 'Required for dubbing';
                }
            }
        }

        // File handling
        function handleFile(file) {
            if (!file) return;
            if (!file.type.startsWith('video/')) {
                showToast('Please upload a video file', 'error');
                return;
            }
            if (file.size > 500 * 1024 * 1024) {
                showToast('File size must be under 500MB', 'error');
                return;
            }

            state.file = file;
            state.videoUrl = URL.createObjectURL(file);

            const zone = document.getElementById('uploadZone');
            zone.classList.add('has-file');
            document.getElementById('fileName').textContent = file.name;
            document.getElementById('fileSize').textContent = formatSize(file.size);

            const preview = document.getElementById('videoPreview');
            const video = document.getElementById('previewVideo');
            video.src = state.videoUrl;
            preview.classList.add('show');

            updateProcessBtn();
        }

        function removeFile() {
            state.file = null;
            if (state.videoUrl) URL.revokeObjectURL(state.videoUrl);
            state.videoUrl = null;

            document.getElementById('uploadZone').classList.remove('has-file');
            document.getElementById('videoPreview').classList.remove('show');
            document.getElementById('fileInput').value = '';
            updateProcessBtn();
        }

        function formatSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        function toggleOption(opt) {
            state.options[opt] = !state.options[opt];
            const elMap = { subtitle: 'optSubtitle', dubbing: 'optDubbing', burnSub: 'optBurnSub' };
            document.getElementById(elMap[opt]).classList.toggle('selected', state.options[opt]);
            updateVoiceSection();
            updateProcessBtn();
        }

        function updateVoiceSection() {
            document.getElementById('voiceSection').classList.toggle('show', state.options.dubbing);
            document.getElementById('burnOption').style.display = state.options.subtitle ? 'block' : 'none';
            if (!state.options.subtitle) {
                state.options.burnSub = false;
                document.getElementById('optBurnSub').classList.remove('selected');
            }
        }

        function selectVoice(el) {
            document.querySelectorAll('.voice-card').forEach(c => c.classList.remove('selected'));
            el.classList.add('selected');
            state.voice = el.dataset.voice;
        }

        function updateProcessBtn() {
            const btn = document.getElementById('processBtn');
            const hasFile = !!state.file;
            const hasOption = state.options.subtitle || state.options.dubbing;
            const hasKeys = state.keys.openai.startsWith('sk-') && state.keys.grok.startsWith('xai-');
            const hasTtsKey = !state.options.dubbing || state.keys.eleven.length > 10;

            btn.disabled = !(hasFile && hasOption && hasKeys && hasTtsKey);
        }

        // Processing
        async function startProcessing() {
            const btn = document.getElementById('processBtn');
            btn.disabled = true;
            btn.innerHTML = '<div class="spinner"></div> Processing...';

            document.getElementById('pipeline').classList.add('show');
            document.getElementById('results').classList.remove('show');
            resetPipeline();

            try {
                updateStep('stepExtract', 'active', 'Extracting audio...', 'Converting video to audio format');
                const audioBlob = await extractAudio(state.file);
                state.videoDuration = await getVideoDuration(state.file);
                updateStep('stepExtract', 'done');

                updateStep('stepTranscribe', 'active', 'Transcribing audio...', 'Using OpenAI Whisper for speech recognition');
                const transcript = await transcribeAudio(audioBlob);
                updateStep('stepTranscribe', 'done');

                updateStep('stepTranslate', 'active', 'Translating to Korean...', 'Using Grok for accurate translation');
                const translated = await translateText(transcript);
                state.transcript = translated;
                updateStep('stepTranslate', 'done');

                if (state.options.dubbing) {
                    updateStep('stepTTS', 'active', 'Generating Korean audio...', 'Creating audio for each segment');
                    state.audioSegments = await generateSegmentTTS(translated);
                    updateStep('stepTTS', 'done');
                } else {
                    document.getElementById('stepTTS').style.opacity = '0.3';
                }

                if (state.options.dubbing && state.audioSegments.length > 0) {
                    updateStep('stepCompose', 'active', 'Composing final video...', 'Syncing audio with timestamps');
                    try {
                        state.videoBlob = await composeVideoWithSegments();
                        updateStep('stepCompose', 'done');
                    } catch (composeError) {
                        console.error('Compose error:', composeError);
                        if (composeError.message.includes('Failed to fetch')) {
                            throw new Error('Server not running. Run: node server.js');
                        }
                        throw composeError;
                    }
                } else {
                    document.getElementById('stepCompose').style.opacity = '0.3';
                }

                updateStep('stepDone', 'done', 'Processing complete!', state.videoBlob ? 'Your Korean dubbed video is ready' : 'Audio and subtitles ready');
                showResults();
                showToast('Processing complete!', 'success');

            } catch (error) {
                console.error(error);
                showToast(error.message || 'Processing failed', 'error');
                updateStep(getCurrentStep(), 'error');
            } finally {
                btn.disabled = false;
                btn.innerHTML = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                    <polygon points="5 3 19 12 5 21 5 3"/>
                </svg> Start Processing`;
            }
        }

        function resetPipeline() {
            ['stepExtract', 'stepTranscribe', 'stepTranslate', 'stepTTS', 'stepCompose', 'stepDone'].forEach(id => {
                const el = document.getElementById(id);
                el.className = 'pipeline-step';
                el.style.opacity = '1';
            });
        }

        let currentStep = null;
        function getCurrentStep() { return currentStep; }

        function updateStep(stepId, status, statusText, detailText) {
            if (status === 'active' || status === 'done' || status === 'error') {
                const el = document.getElementById(stepId);
                el.className = `pipeline-step ${status}`;
                currentStep = stepId;
            }
            if (statusText) document.getElementById('stepStatus').textContent = statusText;
            if (detailText) document.getElementById('stepDetail').textContent = detailText;
        }

        // Extract audio from video (client-side using Web Audio API)
        async function extractAudio(videoFile) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(videoFile);
                video.load();

                video.onloadedmetadata = async () => {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const response = await fetch(video.src);
                        const arrayBuffer = await response.arrayBuffer();
                        const audioBuffer = await audioContext.decodeAudioData(arrayBuffer);
                        
                        // Convert to WAV
                        const wavBlob = audioBufferToWav(audioBuffer);
                        resolve(wavBlob);
                    } catch (e) {
                        // Fallback: just use the video file as-is (server will extract)
                        resolve(videoFile);
                    }
                };

                video.onerror = () => resolve(videoFile);
            });
        }

        async function getVideoDuration(file) {
            return new Promise((resolve) => {
                const video = document.createElement('video');
                video.src = URL.createObjectURL(file);
                video.onloadedmetadata = () => {
                    resolve(video.duration);
                    URL.revokeObjectURL(video.src);
                };
                video.onerror = () => resolve(60);
            });
        }

        function audioBufferToWav(buffer) {
            const numChannels = 1;
            const sampleRate = 16000;
            const format = 1;
            const bitDepth = 16;

            // Resample and convert to mono
            const originalRate = buffer.sampleRate;
            const ratio = sampleRate / originalRate;
            const newLength = Math.round(buffer.length * ratio);
            
            const offlineCtx = new OfflineAudioContext(numChannels, newLength, sampleRate);
            const source = offlineCtx.createBufferSource();
            source.buffer = buffer;
            source.connect(offlineCtx.destination);
            source.start();

            return new Promise(resolve => {
                offlineCtx.startRendering().then(renderedBuffer => {
                    const samples = renderedBuffer.getChannelData(0);
                    const dataLength = samples.length * 2;
                    const wavBuffer = new ArrayBuffer(44 + dataLength);
                    const view = new DataView(wavBuffer);

                    // WAV header
                    writeString(view, 0, 'RIFF');
                    view.setUint32(4, 36 + dataLength, true);
                    writeString(view, 8, 'WAVE');
                    writeString(view, 12, 'fmt ');
                    view.setUint32(16, 16, true);
                    view.setUint16(20, format, true);
                    view.setUint16(22, numChannels, true);
                    view.setUint32(24, sampleRate, true);
                    view.setUint32(28, sampleRate * numChannels * bitDepth / 8, true);
                    view.setUint16(32, numChannels * bitDepth / 8, true);
                    view.setUint16(34, bitDepth, true);
                    writeString(view, 36, 'data');
                    view.setUint32(40, dataLength, true);

                    // Audio data
                    let offset = 44;
                    for (let i = 0; i < samples.length; i++) {
                        const s = Math.max(-1, Math.min(1, samples[i]));
                        view.setInt16(offset, s < 0 ? s * 0x8000 : s * 0x7FFF, true);
                        offset += 2;
                    }

                    resolve(new Blob([wavBuffer], { type: 'audio/wav' }));
                });
            });

            function writeString(view, offset, string) {
                for (let i = 0; i < string.length; i++) {
                    view.setUint8(offset + i, string.charCodeAt(i));
                }
            }
        }

        // Transcribe with Whisper
        async function transcribeAudio(audioBlob) {
            const formData = new FormData();
            formData.append('file', audioBlob, 'audio.wav');
            formData.append('model', 'whisper-1');
            formData.append('language', 'en');
            formData.append('response_format', 'verbose_json');
            formData.append('timestamp_granularities[]', 'segment');

            const response = await fetch('https://api.openai.com/v1/audio/transcriptions', {
                method: 'POST',
                headers: { 'Authorization': `Bearer ${state.keys.openai}` },
                body: formData
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error?.message || 'Transcription failed');
            }

            const data = await response.json();
            return data.segments || [{ text: data.text, start: 0, end: 0 }];
        }

        async function translateText(segments) {
            const textsToTranslate = segments.map(s => s.text).join('\n---\n');

            const response = await fetch('https://api.x.ai/v1/chat/completions', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'Authorization': `Bearer ${state.keys.grok}`
                },
                body: JSON.stringify({
                    model: 'grok-3-fast',
                    messages: [{
                        role: 'system',
                        content: 'Translate each English segment to natural Korean. Keep the same number of segments separated by ---. Output only the Korean translations, nothing else.'
                    }, {
                        role: 'user',
                        content: textsToTranslate
                    }],
                    temperature: 0.3
                })
            });

            if (!response.ok) {
                const err = await response.json();
                throw new Error(err.error?.message || 'Translation failed');
            }

            const data = await response.json();
            const translations = data.choices[0].message.content.split(/\n---\n|\n\n/).map(t => t.trim()).filter(t => t);

            return segments.map((seg, i) => ({
                start: seg.start,
                end: seg.end,
                original: seg.text,
                korean: translations[i] || seg.text
            }));
        }

        function estimateKoreanReadingTime(text) {
            const KOREAN_CHARS_PER_SECOND = 13;
            return text.length / KOREAN_CHARS_PER_SECOND;
        }

        function calculateRequiredSpeed(estimatedDuration, targetDuration) {
            const ratio = estimatedDuration / targetDuration;
            
            if (ratio <= 1.0) {
                return { speed: 1.0, needsCondensation: false, ratio };
            } else if (ratio <= 1.2) {
                return { speed: Math.min(ratio, 1.2), needsCondensation: false, ratio };
            } else if (ratio <= 1.5) {
                return { speed: 1.2, needsCondensation: false, ratio };
            } else {
                return { speed: 1.2, needsCondensation: true, ratio };
            }
        }

        async function condenseKoreanText(text, targetRatio) {
            const targetPercent = Math.round(targetRatio * 100);
            try {
                const response = await fetch('https://api.x.ai/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${state.keys.grok}`
                    },
                    body: JSON.stringify({
                        model: 'grok-3-fast',
                        messages: [{
                            role: 'system',
                            content: `You are a Korean subtitle condenser. Shorten the given Korean text to approximately ${targetPercent}% of its original length while preserving the core meaning. Use natural spoken Korean. Remove redundancies, simplify honorifics where appropriate, and use concise expressions. Output ONLY the condensed Korean text, nothing else.`
                        }, {
                            role: 'user',
                            content: text
                        }],
                        temperature: 0.3
                    })
                });

                if (!response.ok) {
                    console.warn('Condensation failed, using original text');
                    return text;
                }

                const data = await response.json();
                return data.choices[0].message.content.trim();
            } catch (e) {
                console.warn('Condensation error:', e);
                return text;
            }
        }

        async function generateTTS(text, voiceId, speed = 1.0) {
            const clampedSpeed = Math.max(0.7, Math.min(1.2, speed));
            const response = await fetch(`https://api.elevenlabs.io/v1/text-to-speech/${voiceId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                    'xi-api-key': state.keys.eleven
                },
                body: JSON.stringify({
                    text: text,
                    model_id: 'eleven_multilingual_v2',
                    voice_settings: { 
                        stability: 0.5, 
                        similarity_boost: 0.75,
                        speed: clampedSpeed
                    }
                })
            });

            if (!response.ok) throw new Error('TTS generation failed');
            return await response.blob();
        }

        async function generateSegmentTTS(segments) {
            const audioSegments = [];
            
            for (let i = 0; i < segments.length; i++) {
                const seg = segments[i];
                const targetDuration = seg.end - seg.start;
                
                document.getElementById('stepDetail').textContent = 
                    `Analyzing segment ${i + 1}/${segments.length}...`;
                
                const estimated = estimateKoreanReadingTime(seg.korean);
                const { speed, needsCondensation, ratio } = calculateRequiredSpeed(estimated, targetDuration);
                
                console.log(`Segment ${i}: est=${estimated.toFixed(2)}s, target=${targetDuration.toFixed(2)}s, ratio=${ratio.toFixed(2)}, speed=${speed}`);
                
                let textToSpeak = seg.korean;
                if (needsCondensation) {
                    document.getElementById('stepDetail').textContent = 
                        `Condensing segment ${i + 1}/${segments.length}...`;
                    const targetRatio = Math.max(0.6, 1.0 / ratio * 1.1);
                    textToSpeak = await condenseKoreanText(seg.korean, targetRatio);
                    console.log(`  Condensed: "${seg.korean.substring(0, 20)}..." → "${textToSpeak.substring(0, 20)}..."`);
                }
                
                document.getElementById('stepDetail').textContent = 
                    `Generating audio ${i + 1}/${segments.length} (${speed.toFixed(1)}x)...`;
                
                const audioBlob = await generateTTS(textToSpeak, state.voice, speed);
                
                audioSegments.push({
                    start: seg.start,
                    end: seg.end,
                    audio: audioBlob,
                    originalText: seg.korean,
                    spokenText: textToSpeak,
                    ttsSpeed: speed,
                    estimatedRatio: ratio
                });
                
                await new Promise(r => setTimeout(r, 300));
            }
            
            return audioSegments;
        }

        async function composeVideoWithSegments() {
            document.getElementById('stepDetail').textContent = 'Uploading files to server...';
            
            const formData = new FormData();
            formData.append('video', state.file);
            formData.append('duration', state.videoDuration.toString());
            
            const segmentData = state.audioSegments.map((seg, i) => ({
                index: i,
                start: seg.start,
                end: seg.end,
                ttsSpeed: seg.ttsSpeed || 1.0,
                estimatedRatio: seg.estimatedRatio || 1.0
            }));
            formData.append('segments', JSON.stringify(segmentData));
            
            state.audioSegments.forEach((seg, i) => {
                formData.append(`audio_${i}`, seg.audio, `segment_${i}.mp3`);
            });
            
            if (state.options.burnSub && state.options.subtitle) {
                let srtContent = '';
                state.transcript.forEach((t, i) => {
                    srtContent += `${i + 1}\n`;
                    srtContent += `${formatSrtTime(t.start)} --> ${formatSrtTime(t.end)}\n`;
                    srtContent += `${t.korean}\n\n`;
                });
                formData.append('subtitles', srtContent);
            }
            
            document.getElementById('stepDetail').textContent = 'Composing video with synced audio...';
            
            const response = await fetch('/api/compose-segments', {
                method: 'POST',
                body: formData
            });
            
            if (!response.ok) {
                const error = await response.json();
                throw new Error(error.error || 'Video composition failed');
            }
            
            return await response.blob();
        }



        function showResults() {
            document.getElementById('results').classList.add('show');

            const container = document.getElementById('transcriptContent');
            container.innerHTML = state.transcript.map(t => `
                <div class="transcript-line">
                    <div class="transcript-time">${formatTime(t.start)} - ${formatTime(t.end)}</div>
                    <div class="transcript-text">
                        <div class="transcript-original">${t.original}</div>
                        <div class="transcript-korean">${t.korean}</div>
                    </div>
                </div>
            `).join('');

            if (state.videoBlob) {
                document.getElementById('tabVideo').style.display = 'block';
                document.getElementById('btnDownloadVideo').style.display = 'block';
                const video = document.getElementById('resultVideo');
                video.src = URL.createObjectURL(state.videoBlob);
                showResultTab('video');
            }

            if (state.audioBlob) {
                document.getElementById('tabAudio').style.display = 'block';
                document.getElementById('btnDownloadAudio').style.display = 'block';
                const audio = document.getElementById('resultAudio');
                audio.src = URL.createObjectURL(state.audioBlob);
                audio.onloadedmetadata = () => {
                    document.getElementById('audioDuration').textContent = formatTime(audio.duration);
                };
            }
        }

        function formatTime(seconds) {
            const m = Math.floor(seconds / 60);
            const s = Math.floor(seconds % 60);
            return `${m}:${s.toString().padStart(2, '0')}`;
        }

        function showResultTab(tab) {
            document.querySelectorAll('.result-tab').forEach(t => t.classList.remove('active'));
            document.querySelectorAll('.result-panel').forEach(p => p.classList.remove('active'));
            document.querySelector(`.result-tab[onclick*="${tab}"]`).classList.add('active');
            document.getElementById(`panel${tab.charAt(0).toUpperCase() + tab.slice(1)}`).classList.add('active');
        }

        // Audio playback
        let isPlaying = false;
        function toggleResultAudio() {
            const audio = document.getElementById('resultAudio');
            const icon = document.getElementById('audioPlayIcon');
            
            if (isPlaying) {
                audio.pause();
                icon.innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
            } else {
                audio.play();
                icon.innerHTML = '<rect x="6" y="4" width="4" height="16"/><rect x="14" y="4" width="4" height="16"/>';
            }
            isPlaying = !isPlaying;
        }

        document.getElementById('resultAudio').addEventListener('ended', () => {
            isPlaying = false;
            document.getElementById('audioPlayIcon').innerHTML = '<polygon points="5 3 19 12 5 21 5 3"/>';
        });

        // Downloads
        function downloadSRT() {
            let srt = '';
            state.transcript.forEach((t, i) => {
                srt += `${i + 1}\n`;
                srt += `${formatSrtTime(t.start)} --> ${formatSrtTime(t.end)}\n`;
                srt += `${t.korean}\n\n`;
            });

            const blob = new Blob([srt], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'korean_subtitles.srt';
            a.click();
            URL.revokeObjectURL(url);
        }

        function formatSrtTime(seconds) {
            const h = Math.floor(seconds / 3600);
            const m = Math.floor((seconds % 3600) / 60);
            const s = Math.floor(seconds % 60);
            const ms = Math.floor((seconds % 1) * 1000);
            return `${h.toString().padStart(2, '0')}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')},${ms.toString().padStart(3, '0')}`;
        }

        function downloadAudio() {
            if (!state.audioBlob) return;
            const url = URL.createObjectURL(state.audioBlob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'korean_dubbing.mp3';
            a.click();
            URL.revokeObjectURL(url);
        }

        function downloadVideo() {
            if (!state.videoBlob) return;
            const url = URL.createObjectURL(state.videoBlob);
            const a = document.createElement('a');
            a.href = url;
            const originalName = state.file?.name?.replace(/\.[^/.]+$/, '') || 'video';
            a.download = `${originalName}_korean_dubbed.mp4`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // Toast
        function showToast(msg, type = 'success') {
            const toast = document.getElementById('toast');
            document.getElementById('toastMsg').textContent = msg;
            toast.className = `toast ${type} show`;
            setTimeout(() => toast.classList.remove('show'), 3000);
        }
    </script>
</body>
</html>
